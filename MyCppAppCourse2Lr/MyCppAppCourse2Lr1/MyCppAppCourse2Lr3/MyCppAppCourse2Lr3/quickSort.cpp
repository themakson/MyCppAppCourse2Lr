#include <iostream>
#include <conio.h>
#include <time.h>
using namespace std;

void quickSort(int a[], int left, int right) {
	if (left > right) return; // Ёто нужно дл€ терминальной ветки, потмоу что бесконечные рекурсивные вызовы и делаем такое условие что означает все уже отсортированно и делаем точку возврата
	int p = a[(left + right) / 2]; // средний элемент массива ( опорный элеемнт )
	int i = left; // лева€ граница области
	int j = right; // права€ граница области
	while (i <= j) { // когда мы из цикла выйдем у нас i станет больше j » тогда мы вызываем внизу этого метода  виксорт
		while (a[i] < p) i++;// продвижение индекса i пока не встретим элемент больше или равный опорному
		while (a[j] > p) j--;
		if (i <= j) { // затем нужно помен€ть элементы местами дл€ этого ниже способов "3 стаканов"
			int tmp = a[i];
			a[i] = a[j];
			a[j] = tmp;
			i++;
			j--;
		}
	}
	quickSort(a, left, j); // дл€ левой части массива
	quickSort(a, i, right); // дл€ правой части массива

}

int main() {
	setlocale(LC_ALL, "RU");
	srand(time(0));
	const int N = 10;
	int a[N]; // ћассив a из колличества элементов N (10 Ўтук)
	cout << "»сходный массив:\n"; // «аполнение массива случайными числами от 0 до 15 и вывод на консоль
	for (int i = 0; i < N; i++) {
		a[i] = rand() % 16;
		cout << a[i] << "\t";
	}
	cout << endl;
	quickSort(a, 0, N - 1); // Ќаша функци€ квик —орт (a- им€ массива , 0- иднекс левой границы, N - 1 - индекс правой границы(последний элемент массива))
	cout << "ќтсортированный массив:\n"; // ѕосле сортировки выводим новый отсортированный массив
	for (int i = 0; i < N; i++) {
		cout << a[i] << "\t";
	}
	cout << endl;
	system("pause");
	return 0;

}